// Copyright 2014 Charles Gentry. All rights reserved.
// Please see the license included with this package
//
package gav

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"net/http"
	"errors"
	"time"
	"strings"
)

/* What is used in the HMAC?
*	A request comes in that looks like
* 	GET	/register/mydomain?login=we_want_you&pwd=password&email=user@something&name=john_doe
*
*
*	The authorisation information must occur in the header:
		Authorization: abcd-efg-1234-456:qnR8UCqJggD55PohusaBNviGoOJ67HC6Btry4qXLVZc=

	The split occurs at the first colon (:). The left is the caller's ID. The right is the hmac
	generated by hashing key values.

	The contents of the headers required for authorisation are:
		* The Client ID (always, and in the Authorization header value)
		* The Content-MD5 header (if there is a body)
		* The Content-Type in the header (if present)
		* Either header contents of Timestamp the standard HTTP header 'Date:' in the request
		* The complete request (/register/mydomain?login....)
		* The client secret (not sent in request) is used as the hash key

	The following should be generated per request:
		Rqst	MD5		Type
		GET		No		No
		PUT		Yes		Yes
		DELETE	No		No
		POST	Yes		Yes
*/


const GAV_HEADER_TIMESTAMP	= "Timestamp"
const GAV_HEADER_DATE		= "Date"
const GAV_HEADER_TOKEN		= "Authorization"
const GAV_HEADER_MD5		= "Content-MD5"
const GAV_HEADER_TYPE		= "Content-Type"

type Secure struct{
	TimeWindow	time.Duration
	user		string
	hmacToken	string
}

func NewServer() * Secure {
	return &Secure{ TimeWindow: 15*time.Minute }
}


func ( s * Secure ) decodeAuth( r * http.Request )error {
	if s.user == "" || s.hmacToken == "" {
		parts := strings.SplitN( r.Header.Get( GAV_HEADER_TOKEN ) , ":" , 2 )
		if len( parts ) < 2 {
			return  errors.New(TOKEN_INCOMPLETE)
		}
		s.user = strings.TrimSpace( parts[0] )
		s.hmacToken = strings.TrimSpace(parts[1])
		if len( s.user ) == 0 || len( s.hmacToken ) == 0 {
			return errors.New( TOKEN_MISSING_PARM)
		}
	}
	return nil
}
func( s * Secure ) getUri( r * http.Request ) string {
	// Reconstitued version
	// The RawURI does not include the fragment so we need to build it here...
	val := r.URL.Path
	if r.URL.RawQuery != "" {
		val = val + `?` + r.URL.RawQuery
	}
	if r.URL.Fragment != "" {
		val = val + `#` + r.URL.Fragment
	}
	return val
}

func ( s * Secure ) GetUser( r * http.Request) ( string , error ){
	err:= s.decodeAuth(r)
	return s.user , err
}

func ( s * Secure ) GetSignature( r * http.Request ) ( string , error ){
	err:= s.decodeAuth(r)
	return s.hmacToken , err
}

/*
 * Create a signature value from the request and secret
 */
func ( s * Secure ) RecreateSignature( r * http.Request , secret , body []byte )( string, error ){
	if user, err := s.GetUser( r ); err != nil {
		return "", err
	}else{
		return s.CreateSignature( r , user , secret , body )
	}
}
/**
 * Create a signature value from the request, user and secret and body
 */
func ( s * Secure ) CreateSignature( r * http.Request , user string , secret , body []byte ) ( string , error ){

	if len( secret ) == 0 {
		return "", errors.New( SECRET_INVALID )
	}
	mac := hmac.New( sha256.New , secret )					// Setup with secret key
	mac.Write( []byte( strings.TrimSpace(user) ) )			// Add in user ID
	mac.Write( []byte( s.CalculateContentMD5(body)))		// Add in the MD5 calculate value
	mac.Write( []byte( r.Header.Get( GAV_HEADER_TYPE )))	// Add in Content-Type from header
	mac.Write( []byte( s.getUri(r)))						// add in the re-constituted URI

	return base64.StdEncoding.EncodeToString(mac.Sum( nil ) ), nil
}

func ( s * Secure ) SignRequest( r * http.Request , user string , secret,body []byte) error {
	user = strings.TrimSpace( user )						// Fetch user

	r.Header.Del( GAV_HEADER_MD5)							// Remove+Add Content-MD5
	r.Header.Add( GAV_HEADER_MD5 , s.CalculateContentMD5(body) )
	s.SetSignatureDate( r )									// Add in date for signature

	if signature , err := s.CreateSignature( r, user, secret , body); err != nil {
		return err
	}else{
		r.Header.Del( GAV_HEADER_TOKEN)						// Remove+Add Authorization
		r.Header.Add( GAV_HEADER_TOKEN , fmt.Sprintf( "%s:%s", user,signature ))
	}
	return nil
}

/*
 *	Recreate the signature from the request then compare it to the signature passed to us.
 *  PARM:	HTTP Request
 *			byte array of Signature we expect
 *			byte array Secret
 *			byte array body of message
 */
func ( s * Secure ) CompareSignature(  r * http.Request , signature string ,secret , body []byte  ) error {
	if r.Header.Get( GAV_HEADER_MD5 ) !=  s.CalculateContentMD5(body) {
		return errors.New( MD5_MISMATCH )
	}
	computed,err := s.RecreateSignature( r , secret , body )
	if err != nil {
		if ! hmac.Equal([]byte(signature), []byte( computed)){
			return errors.New( SIGNATURE_INVALID)
		}
	}
	return nil
}

/*
 *	Pull the signature from the header then compare that with a 'recreation' of a
 *  signature we generate from the request
 *  PARM:	HTTP Request
 *			byte array Secret
 *			byte array body of message
 */
func ( s * Secure ) ConfirmSignature( r * http.Request , secret, body [] byte ) error {
	if signature, err  := s.GetSignature( r ); err != nil {
		return err
	}else{
		return s.CompareSignature( r , signature , secret, body )
	}
}


